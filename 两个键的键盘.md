# [两个键的键盘](https://leetcode.cn/problems/2-keys-keyboard/)

![image-20250601142903929](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250601142904151.png)

## 算法原理

有两个解法, 注释里面都写清楚了, 一个是动规, 一个是数学

## 代码编写

```cpp
class Solution {
/*
    定义dp[i][j]表示, 在拼出i长度的字符串时, 最后一步是复制j长度的字符串
    此时, 在最后一步之前的状态就是i-j的长度, 是这个长度再复制j长度的字符串时
    才得到的i长度,
    首先, 我们可以确定j的范围, 很明显, 当i-j小于j时, 是一定复制不出j长度的字符串的
    所以省略, 所以1 <= j <= i / 2, 注意这里的除法是包括小数的, 当j < i / 2时,
    由于再复制之后就就会把之前的内容覆盖掉, 所以此时的i-j的最后一步也必须是j长度复制
    出来的, 即dp[i][j] = dp[i-j][j] + 1, 需要注意的是, 这种方案必须在dp[i-j][j]本身
    可行的时候才会被采纳. 我们用-1表示不可行
    另外一种情况是, j == i / 2, 此时只能采用把i-j整个复制一遍的操作来进行粘贴,那么复制
    加粘贴就是两步, dp[i][j] = min(dp[i-j]) + 2, 为了减少查找min的次数, 我们发现每行的
    [0]其实都是用不上的, 所以我们就可以在这里存储最小的min
    当n=1时, 不需要进行任何粘贴, 所以dp[1][0] = 0;
*/


    int dp[1001][1001];

public:
    int minSteps(int n) {
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 1; j <= i; ++j)
            {
                dp[i][j] = -1;      
            }
        }

        dp[1][0] = 0;
        for(int i = 2; i <= n; ++i)
        {
            double end = i / 2.0;
            dp[i][0] = INT_MAX;
            for(int j = 1; j <= end; ++j)
            {
                if(j == end)
                {
                    dp[i][j] = dp[j][0] + 2;
                }
                else
                {
                    if(dp[i-j][j] == -1) continue;
                    dp[i][j] = dp[i-j][j] + 1;
                }
                if(dp[i][j] != -1)
                    dp[i][0] = min(dp[i][j], dp[i][0]);
            }
        }

        return dp[n][0];
    }
};

class Solution {
/*
    我们定义乘法链  T_i = T_{i-1} * a_i;
    其中T_i表示当前字符串的长度, a_i与粘贴的次数有关
    输入 n = 18
    T_0 = 1; 最开始字符串的长度为一, 这是首项
    T_1 = T_0 * 2; 表示先复制(T_0个字符), 再粘贴(2-1)次, 得到T_1(2)长度的字符串
    T_2 = T_1 * 3; 表示先复制(T_1个字符), 再粘贴(3-1)次, 得到T_2(6)长度的字符串
    T_3 = T_2 * 3; 表示先复制(T_2个字符), 再粘贴(3-1)次, 得到T_3(18)长度的字符串

    总结, 整个过程, 为了得到目标n, 它的过程恰好可以用其因式进行过程描述
    18 = 1 * 2 * 3 * 3;   其中最开始的1一开始就有, 所以不要加, 此时这种方案的步数
    就是2 + 3 + 3 = 8,

    题目要我们找最小的因数和, 这样的话, 其实就变成了纯粹的数学问题, 把一个数拆成不含一的
    因式, 问因式和最小该怎么办? 只要因式都是质数, 就是最小的
    如何找质因数? 如何分解因因式?
    从2开始, 每次加加, 看目标是否能被整除, 能被整除, 就记录, 并修正目标
    for 2 -> n (不包含n)
    {
        while(n % i == 0)  //可能有多个相同的质因数
        {
            i记录
            n /= i;
        }
    }

    如何保证质数性? 对于那些非质数而言, 它们一定能被分解成质数
    所以在比如对于非质数4, 有质因数2, 而在2的时候, 所有的2已经被除
    尽了, 所以会让4天然不能被整除
*/



public:
    int minSteps(int n) {
        int ans = 0;
        for(int i = 2; i < n; ++i)
        {
            while(n % i == 0)
            {
                ans += i;
                n /= i;
            }
        }

        // 如果n本身是质数, 则此时它仍旧会大于1, 并且由于质数不可被分解
        // 所以ans现在还是零
        if(n > 1) ans += n;

        return ans;
    }
};
```

# 完

