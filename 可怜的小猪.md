# [可怜的小猪](https://leetcode.cn/problems/poor-pigs/)

![image-20250518185421598](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250518185421768.png)

## 题目解析

尽管我是在动规专题找到它的, 但我必须要说, 这题用动规就是在害人. 动规的逻辑异常复杂, 也非常难懂, 在我个人看来, 完全可以舍弃.

## 算法原理

首先, 依据`minutesToDie`和`minutesToTest`, 我们可以得到进行实验的最大轮次, `T = minutesToTest / minutesToDie;`, 让我们先来看看`T == 1`的时候是什么情况.

当`T`等于`1`时, 每只小猪的实验结果都只有两种可能, 一种是在第一轮试验后, 还活着, 另外一种可能, 是在第一轮实验后, 死了, 因此, 当`T = 1`时, 每只小猪可以表示两种状态的可能, 这就类似于一个比特位只能表示`1, 0`这两种结果一样.

因此, 在只进行一轮实验的前提下, 我们把每只猪当做一个比特位

一只小猪可以表示两种状态, 分别是`0, 1`, `0`的意思就是编号为零的桶是毒药, `1`的意思就是编号为一的桶是毒药
两只小猪可以表示四种状态, 分别是`00, 01, 10, 11`, `00`的意思就是编号为零的桶是毒药, `01`的意思就是编号为一的桶是毒药, `10`的意思是编号为二的桶是毒药, `11`表示编号为三的桶是毒药
........

三只小猪可以表示九种状态

也就是说, 问题被纯粹转化成编码问题, 多少位的二进制序列可以表示多少个数, 从而确定一个特定的编号, 该特定编号便是毒药的编号

当`T`等于2时, 对于每只小猪来说, 它可以在第一轮后死, 可以在第二轮后死, 可以一直活着, 这样就会有三种状态, 问题就被转化层三进制的编码问题.

因此对于`T`轮来说, 每只小猪最多可以表示`T+1`种状态, 这样的话, 设有`x`只小猪, 那么它们能表示的编码数目, 或者是有多少种特定编号, 就是`(T+1)^X`, 因此, 对于`buckets`来说, 只需要找到一个`x`, 使`(T+1)^X`大于等于`buckets`即可, 因此

$$x >= log_{T+1}buckets$$

我们取满足上述条件最小的整数`x`,因为小猪的个数只能为整数

每只猪能携带 log(T+1) bits 的信息，最终形成的信息组合必须能覆盖所有桶编号，问题的本质是信息论而非动态规划。

## 代码编写

$$log_{T+1}buckets = log(buckets) / log(T+1)$$(换底公式)

由于C++的`log`返回的是浮点型, 并且总会有一定的误差, 所以会导致取整异常, 所以我们就自己手动取求对数

```cpp
class Solution {
    public:
    int poorPigs(int buckets, int minutesToDie, int minutesToTest) {
        int states = minutesToTest / minutesToDie + 1;
        int pigs = 0, capacity = pow(states, 0);
        while(capacity < buckets)
        {
            ++pigs;
            capacity *= states;
        }

        return pigs;
    }
};             
```

 # 完

